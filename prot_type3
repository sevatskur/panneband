#include "mcc_generated_files/system/system.h"
#include "mcc_generated_files/system/pins.h" 
#include "mcc_generated_files/vref/vref.h"
#include <avr/io.h>
#include <avr/sleep.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdio.h>

#define PIN_PW (1 << 0)   // PD0 for pw pin
#define PIN_PW_1 (1 << 1) // PD1 for pw pin 
#define PIN_PW_2 (1 << 2)
#define PIN_PWM (1 << 0)  // PB0 for vibration motor
#define PIN_PWM_1 (1 << 1)
#define PIN_PWM_2 (1 << 2)
#define START_PIN (1 << 5)
#define PERIOD 0x9c3      // pwm variable
#define N 4               // For 2^N
#define CIRCULAR_BUFFER_SIZE (1 << N) //Gir bufferstørrelse 2^N

uint16_t adc_result[3]; // array to store data for each sensor
float adc_result_flat[3]; //average adc values after being filtered
float distance_cm[3]; // array for 3 different distances
int adc_pins[3] = {ADC0_IO_PD0, ADC0_IO_PD1, ADC0_IO_PD2}; // Distance sensor pins
uint8_t duty_cycle[3]; //distance to pwm array

typedef struct {
    int16_t * const buffer1; // buffer 1
    unsigned writeIndex1; // write index to buffer 1

    int16_t * const buffer2;
    unsigned writeIndex2;

    int16_t * const buffer3;
    unsigned writeIndex3;
} circular_buffer_t;

void circular_buffer_write(circular_buffer_t *c, int16_t data, int8_t buffer_number);
int16_t circular_buffer_read(circular_buffer_t *c, unsigned Xn, int8_t buffer_number);
int32_t accumolator(int16_t sample, int8_t buffer_number);
uint8_t map_distance_to_duty_cycle(float distance_cm);
int16_t adc_switch_and_read(int pin_index);
int find_min_index(float array[], int size);

int main(void) {
    SYSTEM_Initialize();

    _delay_ms(40);
    PORTC.DIRCLR = START_PIN;

    while (1) {

        for (int i = 0; i < 3; i++) {

            adc_result[i] = adc_switch_and_read(i); // adc result for each pin

            adc_result_flat[i] = accumolator(adc_result[i], i); // filtered result

            distance_cm[i] = (float) adc_result_flat[i] * 0.150; // distance for each pin

            duty_cycle[i] = map_distance_to_duty_cycle(distance_cm[i]); //duty cycle to set pwm          
        }

        int min_index = find_min_index(adc_result_flat, 3); // finds the sensor thats closest to an object

        for (int i = 0; i < 3; i++) { //vibrates the one thats closest to an object
            if(i == min_index){
                if(i == 0){ 
                    TCA1.SINGLE.CMP0 = (PERIOD * duty_cycle[0]) / 100;
                }
                else if(i == 1){
                    TCA1.SINGLE.CMP1 = (PERIOD * duty_cycle[1]) / 100;
                }
                else if(i == 2){
                    TCA1.SINGLE.CMP2 = (PERIOD * duty_cycle[2]) / 100;
                }
            }
            else{
                duty_cycle[i] = 0;
            }
        }

        /*printf("Duty1 : %u \r\n", duty_cycle[0]);
        printf("Duty2 : %u \r\n", duty_cycle[1]);
        printf("Duty3 : %u \r\n", duty_cycle[2]);*/
        printf("dist1 : %.2f \r\n", adc_result_flat[0]);
        printf("dist2 : %.2f \r\n", adc_result_flat[1]);
        printf("dist3 : %.2f \r\n", adc_result_flat[2]);
    }
}

void circular_buffer_write(circular_buffer_t *c, int16_t data, int8_t buffer_number) {
    if (buffer_number == 0) {
        c -> buffer1[c->writeIndex1] = data;
        c->writeIndex1 = (c->writeIndex1 + 1) % CIRCULAR_BUFFER_SIZE;
    } else if (buffer_number == 1) {
        c -> buffer2[c->writeIndex2] = data;
        c->writeIndex2 = (c->writeIndex2 + 1) % CIRCULAR_BUFFER_SIZE;
    } else if (buffer_number == 2) {

        c -> buffer3[c->writeIndex3] = data;
        c->writeIndex3 = (c->writeIndex3 + 1) % CIRCULAR_BUFFER_SIZE;
    }
}

int16_t circular_buffer_read(circular_buffer_t *c, unsigned Xn, int8_t buffer_number) {
    if (buffer_number == 0) {
        return c->buffer1[(c->writeIndex1 - Xn + CIRCULAR_BUFFER_SIZE - 1) % CIRCULAR_BUFFER_SIZE];
    } else if (buffer_number == 1) {
        return c->buffer2[(c->writeIndex2 - Xn + CIRCULAR_BUFFER_SIZE - 1) % CIRCULAR_BUFFER_SIZE];
    } else if (buffer_number == 2) {

        return c->buffer3[(c->writeIndex3 - Xn + CIRCULAR_BUFFER_SIZE - 1) % CIRCULAR_BUFFER_SIZE];
    }
    return 0;
}

int32_t accumolator(int16_t sample, int8_t buffer_number) {
    //Deklarerer en ringbuffer med dataområde gitt av CIRCULAR_BUFFER_SIZE
    static int16_t bufferDataSpace1[CIRCULAR_BUFFER_SIZE];
    static int16_t bufferDataSpace2[CIRCULAR_BUFFER_SIZE];
    static int16_t bufferDataSpace3[CIRCULAR_BUFFER_SIZE];
    static int32_t sum[3] = {0};

    static circular_buffer_t c = {
        .buffer1 = bufferDataSpace1,
        .buffer2 = bufferDataSpace2,
        .buffer3 = bufferDataSpace3,
        .writeIndex1 = 0,
        .writeIndex2 = 0,
        .writeIndex3 = 0
    };
    //skriver til ringbufffer
    circular_buffer_write(&c, sample, buffer_number);

    static int16_t counter[] = {0, 0, 0}; // counter elements 0, 1 and 2

    //Sjekker om ringbufferen har blitt lagt sammen en gang
    if (counter[buffer_number] >= CIRCULAR_BUFFER_SIZE) {
        //trekker fra edlste verdi og legger deretter på nyeste verdi
        sum[buffer_number] -= circular_buffer_read(&c, CIRCULAR_BUFFER_SIZE - 1, buffer_number);
        sum[buffer_number] += circular_buffer_read(&c, 0, buffer_number);
    }//legger sammen alle verdiene i ringbufferen ved første gjennomkjøring
    else {
        if (buffer_number == 0) {
            for (uint16_t n = 0; n < CIRCULAR_BUFFER_SIZE; n++) {
                sum[buffer_number] += (int32_t) c.buffer1[n];
            }
            counter[0]++;
        } else if (buffer_number == 1) {
            for (uint16_t n = 0; n < CIRCULAR_BUFFER_SIZE; n++) {
                sum[buffer_number] += (int32_t) c.buffer2[n];
            }
            counter[1]++;
        } else if (buffer_number == 2) {
            for (uint16_t n = 0; n < CIRCULAR_BUFFER_SIZE; n++) {

                sum[buffer_number] += (int32_t) c.buffer3[n];
            }
            counter[2]++;
        }
        counter[buffer_number] = CIRCULAR_BUFFER_SIZE;
    }
    //printf("sum1 = %u \r\n", sum[1]/CIRCULAR_BUFFER_SIZE);
    return sum[buffer_number] / CIRCULAR_BUFFER_SIZE;
}

int16_t adc_switch_and_read(int pin_index) {

    ADC0.MUXPOS = adc_pins[pin_index];
    //_delay_ms(48); // to avoid interferance between channels


    // Start ADC conversion
    ADC0.COMMAND = ADC_STCONV_bm;

    // Wait for conversion to complete
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));

    // Clear the result-ready flag
    ADC0.INTFLAGS = ADC_RESRDY_bm;

    // Return ADC result
    return ADC0.RES;
}

uint8_t map_distance_to_duty_cycle(float distance_cm) {
    uint16_t max_distance = 300; // Maks avstand for duty cycle
    int16_t duty_cycle = 100 - (distance_cm * 100 / max_distance);

    // Begrens duty cycle til området 0-100
    if (duty_cycle > 100) {
        duty_cycle = 100;
    } else if (duty_cycle < 0) {
        duty_cycle = 0;
    }

    return duty_cycle;
}

int find_min_index(float array[], int size) {
    int min_index = 0; // Start med første element som minste
    float min_value = array[0];

    for (int i = 1; i < size; i++) { // Sjekk resten av arrayen
        if (array[i] < min_value) { // Oppdater hvis vi finner en mindre verdi
            min_value = array[i];
            min_index = i;
        }
    }
    return min_index; // Returner indeksen til den minste verdien
}
