#include "mcc_generated_files/system/system.h"
#include "mcc_generated_files/system/pins.h" 
#include "mcc_generated_files/vref/vref.h"
#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>

#define PIN_RX (1 << 0)   //En udefinert pin som skal brukes til RXen til sensoren
#define PIN_PW (1 << 0)   // PD0 for pw pin
#define PIN_PW_1 (1 << 1) // PD1 for pw pin 
#define PIN_PW_2 (1 << 2)
#define PIN_PWM (1 << 0)  // PB0 for vibration motor
#define PIN_PWM_1 (1 << 1)
#define PIN_PWM_2 (1 << 2)
#define PERIOD 0x9c3      // pwm variable
#define N 4               // For 2^N
#define CIRCULAR_BUFFER_SIZE (1 << N) //Gir bufferstørrelse 2^N

uint16_t adc_result[3]; // array to store data for each sensor
float adc_result_flat[3]; //average adc values after being filtered
float distance_cm[3]; // array for 3 different distances
int adc_pins[3] = {ADC0_IO_PD0, ADC0_IO_PD1, ADC0_IO_PD2}; // Distance sensor pins
uint8_t duty_cycle[3]; //distance to pwm array
int sensor_logic(float distance_cm[3], int size); //sensor logic

int size = 3; //for sensor logic

typedef struct {
    int16_t * const buffer1; // buffer 1
    unsigned writeIndex1; // write index to buffer 1

    int16_t * const buffer2;
    unsigned writeIndex2;

    int16_t * const buffer3;
    unsigned writeIndex3;
} circular_buffer_t;

void circular_buffer_write(circular_buffer_t *c, int16_t data, int8_t buffer_number);
int16_t circular_buffer_read(circular_buffer_t *c, unsigned Xn, int8_t buffer_number);
int32_t accumolator(int16_t sample, int8_t buffer_number);
void calculate_distance(uint16_t adc_result_flat[3], float distance[3]);
void map_distance_to_duty_cycle(float distance_cm[], uint8_t duty_cycle[]);
void sensor_timing();

int main(void) {
    // Initial setup
    PORTD.DIRCLR = PIN_PW; // input sensor 1
    PORTD.DIRCLR = PIN_PW_1; // input sensor 2
    PORTD.DIRCLR = PIN_PW_2; // input sensor 3
    SYSTEM_Initialize();


    while (1) {
        int min_index = sensor_logic(distance_cm, size);

        for (int i = 0; i < 3; i++) {
            if (i == 0) {
                PORTD.DIRCLR = PIN_PW; // Enable sensor 1 as input
                PORTD.DIRSET = PIN_PW_1; // Set sensor 2 as output
                PORTD.DIRSET = PIN_PW_2; // Set sensor 3 as output
                if (0 == min_index) {
                    PORTB.DIRSET = PIN_PWM;
                } else {
                    PORTB.DIRCLR = PIN_PWM;
                }
            } else if (i == 1) {
                PORTD.DIRCLR = PIN_PW_1; // Enable sensor 2 as input
                PORTD.DIRSET = PIN_PW; // Set sensor 1 as output
                PORTD.DIRSET = PIN_PW_2; // Set sensor 3 as output
                if (1 == min_index) {
                    PORTB.DIRSET = PIN_PWM_1;
                } else {
                    PORTB.DIRCLR = PIN_PWM_1;
                }
            } else if (i == 2) {
                PORTD.DIRCLR = PIN_PW_2; // Enable sensor 3 as input
                PORTD.DIRSET = PIN_PW; // Set sensor 1 as output
                PORTD.DIRSET = PIN_PW_1; // Set sensor 2 as output
                if (2 == min_index) {
                    PORTB.DIRSET = PIN_PWM_2;
                } else {
                    PORTB.DIRCLR = PIN_PWM_2;
                }
            }
            _delay_ms(10);

            // Start ADC conversion on the selected channel
            ADC0_StartConversion(adc_pins[i]);
            while (!ADC0_IsConversionDone()); // Wait for conversion to complete

            // Store the ADC result and accumulate it
            adc_result[i] = ADC0_GetConversionResult();
            adc_result_flat[i] = (float) accumolator(adc_result[i], i); // Store accumulated value

            _delay_ms(1); // Delay to allow settling before next conversion
        }

        calculate_distance(adc_result, distance_cm);
        map_distance_to_duty_cycle(distance_cm, duty_cycle);


        //printf("Distance1 : %.2f \r\n", distance_cm[0]);
        printf("Duty_cycle1: %u \r\n", duty_cycle[0]);
        //printf("sum1: %.2f \r\n", adc_result_flat[0]);
        //printf("sum1: %.2f \r\n", adc_result_flat[1]);

    }
}

void circular_buffer_write(circular_buffer_t *c, int16_t data, int8_t buffer_number) {
    if (buffer_number == 0) {
        c -> buffer1[c->writeIndex1] = data;
        c->writeIndex1 = (c->writeIndex1 + 1) % CIRCULAR_BUFFER_SIZE;
    } else if (buffer_number == 1) {
        c -> buffer2[c->writeIndex2] = data;
        c->writeIndex2 = (c->writeIndex2 + 1) % CIRCULAR_BUFFER_SIZE;
    } else if (buffer_number == 2) {

        c -> buffer3[c->writeIndex3] = data;
        c->writeIndex3 = (c->writeIndex3 + 1) % CIRCULAR_BUFFER_SIZE;
    }
}

int16_t circular_buffer_read(circular_buffer_t *c, unsigned Xn, int8_t buffer_number) {
    if (buffer_number == 0) {
        return c->buffer1[(c->writeIndex1 - Xn + CIRCULAR_BUFFER_SIZE - 1) % CIRCULAR_BUFFER_SIZE];
    } else if (buffer_number == 1) {
        return c->buffer2[(c->writeIndex2 - Xn + CIRCULAR_BUFFER_SIZE - 1) % CIRCULAR_BUFFER_SIZE];
    } else if (buffer_number == 2) {

        return c->buffer3[(c->writeIndex3 - Xn + CIRCULAR_BUFFER_SIZE - 1) % CIRCULAR_BUFFER_SIZE];
    }
    return 0;
}

int32_t accumolator(int16_t sample, int8_t buffer_number) {
    //Deklarerer en ringbuffer med dataområde gitt av CIRCULAR_BUFFER_SIZE
    static int16_t bufferDataSpace1[CIRCULAR_BUFFER_SIZE];
    static int16_t bufferDataSpace2[CIRCULAR_BUFFER_SIZE];
    static int16_t bufferDataSpace3[CIRCULAR_BUFFER_SIZE];
    static int32_t sum[3] = {0};

    static circular_buffer_t c = {
        .buffer1 = bufferDataSpace1,
        .buffer2 = bufferDataSpace2,
        .buffer3 = bufferDataSpace3,
        .writeIndex1 = 0,
        .writeIndex2 = 0,
        .writeIndex3 = 0
    };
    //skriver til ringbufffer
    circular_buffer_write(&c, sample, buffer_number);

    static int16_t counter[] = {0, 0, 0, 0}; // we use elements 1, 2, and 3 only

    //Sjekker om ringbufferen har blitt lagt sammen en gang
    if (counter[buffer_number] >= CIRCULAR_BUFFER_SIZE) {
        //trekker fra edlste verdi og legger deretter på nyeste verdi
        sum[buffer_number] -= circular_buffer_read(&c, CIRCULAR_BUFFER_SIZE - 1, buffer_number);
        sum[buffer_number] += circular_buffer_read(&c, 0, buffer_number);
    }//legger sammen alle verdiene i ringbufferen ved første gjennomkjøring
    else {
        if (buffer_number == 0) {
            for (uint16_t n = 0; n < CIRCULAR_BUFFER_SIZE; n++) {
                sum[buffer_number] += (int32_t) c.buffer1[n];
            }
            counter[1]++;
        } else if (buffer_number == 1) {
            for (uint16_t n = 0; n < CIRCULAR_BUFFER_SIZE; n++) {
                sum[buffer_number] += (int32_t) c.buffer2[n];
            }
            counter[2]++;
        } else if (buffer_number == 2) {
            for (uint16_t n = 0; n < CIRCULAR_BUFFER_SIZE; n++) {

                sum[buffer_number] += (int32_t) c.buffer3[n];
            }
            counter[3]++;
        }
        counter[buffer_number] = CIRCULAR_BUFFER_SIZE;
    }
    //printf("sum1 = %u \r\n", sum[1]/CIRCULAR_BUFFER_SIZE);
    return sum[buffer_number] / CIRCULAR_BUFFER_SIZE;
}

void calculate_distance(uint16_t adc_result_flat[], float distance[3]) {
    for (int i = 0; i < 3; i++) {
        distance[i] = adc_result_flat[i] * 0.107; // scaling factor tested irl
    }
}

void map_distance_to_duty_cycle(float distance_cm[], uint8_t duty_cycle[]) {
    uint16_t max_distance = 300; // chosen max distance

    for (int i = 0; i < 3; i++) {
        duty_cycle[i] = 100 - (distance_cm[i] * 100 / max_distance);

        // Clamp the duty cycle within the 0-100 range
        if (duty_cycle[i] > 100) {
            duty_cycle[i] = 0;
        } else if (duty_cycle[i] < 0) {
            duty_cycle[i] = 100;
        }
    }
}

int sensor_logic(float distance_cm[3], int size) {

    int min_index = 0; // Start with the first element's index as the largest

    for (int i = 1; i < size; i++) {
        if (distance_cm[i] < distance_cm[min_index]) {
            min_index = i; // Update max_index if current element is larger
        }
    }
    return min_index;
}


////////// Suedo kode for pulstog, se sensor datasheet side 5 for mere detaljer ///////////
void sensor_timing(){
    static int32_t timer = 0;
    if(timer >= 50){ //i ms
        //Sett pin RX høy i 2 ms
        timer = 0; //resett timer
    }
    
}
